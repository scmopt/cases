[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cases",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "cases",
    "section": "Install",
    "text": "Install\npip install cases"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "cases",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "foo\n\n foo ()"
  },
  {
    "objectID": "agricultural_pricing.html",
    "href": "agricultural_pricing.html",
    "title": "Agricultural Pricing",
    "section": "",
    "text": "The government of a country wants to decide what prices should be charged for its dairy products: milk, butter, and cheese. All these products are produced (directly or indirectly) from the country’s raw milk production operations. This raw milk is divided into two main components: fat and dry matter. After subtracting the quantities of fat and dry matter, which are used for making products for export or consumption on the farms, there is a total yearly availability of 600,000 tons of fat and 750,000 tons of dry matter. This is all available for producing milk, butter and two kinds of cheese for domestic consumption. The percentage composition of the products are given in the following table:\n\n\n\nComposition\nFat (%)\nDry matter (%)\n\n\n\n\nMilk\n4\n9\n\n\nButter\n80\n2\n\n\nCheese 1\n35\n30\n\n\nCheese 2\n25\n40\n\n\n\nThe table below shows last year’s domestic consumption (demand) and prices for the dairy products:\n\n\n\nDairy  products\nMilk\nButter\nCheese 1\nCheese 2\n\n\n\n\nDemand (1000 tons)\n4.82\n0.32\n0.21\n0.07\n\n\nPrice (dollars/ton)\n297\n720\n1050\n815\n\n\n\nThe elasticities and cross-elasticities are given in the table below:\n\n\n\n\n\n\n\n\n\n\n\nMilk\nButter\nCheese 1\nCheese 2\nCheese 1 to  Cheese 2\nCheese 2 to  Cheese 1\n\n\n\n\n0.4\n2.7\n1.1\n0.4\n0.1\n0.4\n\n\n\nThe price index cannot be raised higher than last year.This constraint establishes that the new prices must be such that the total cost of last year’s consumption would not be increased. Last year’s price index is 1.939 (measured in thousand dollars).\nThe goal is to determine what prices and demand maximizes the total revenue."
  },
  {
    "objectID": "agricultural_pricing.html#problem-description",
    "href": "agricultural_pricing.html#problem-description",
    "title": "Agricultural Pricing",
    "section": "",
    "text": "The government of a country wants to decide what prices should be charged for its dairy products: milk, butter, and cheese. All these products are produced (directly or indirectly) from the country’s raw milk production operations. This raw milk is divided into two main components: fat and dry matter. After subtracting the quantities of fat and dry matter, which are used for making products for export or consumption on the farms, there is a total yearly availability of 600,000 tons of fat and 750,000 tons of dry matter. This is all available for producing milk, butter and two kinds of cheese for domestic consumption. The percentage composition of the products are given in the following table:\n\n\n\nComposition\nFat (%)\nDry matter (%)\n\n\n\n\nMilk\n4\n9\n\n\nButter\n80\n2\n\n\nCheese 1\n35\n30\n\n\nCheese 2\n25\n40\n\n\n\nThe table below shows last year’s domestic consumption (demand) and prices for the dairy products:\n\n\n\nDairy  products\nMilk\nButter\nCheese 1\nCheese 2\n\n\n\n\nDemand (1000 tons)\n4.82\n0.32\n0.21\n0.07\n\n\nPrice (dollars/ton)\n297\n720\n1050\n815\n\n\n\nThe elasticities and cross-elasticities are given in the table below:\n\n\n\n\n\n\n\n\n\n\n\nMilk\nButter\nCheese 1\nCheese 2\nCheese 1 to  Cheese 2\nCheese 2 to  Cheese 1\n\n\n\n\n0.4\n2.7\n1.1\n0.4\n0.1\n0.4\n\n\n\nThe price index cannot be raised higher than last year.This constraint establishes that the new prices must be such that the total cost of last year’s consumption would not be increased. Last year’s price index is 1.939 (measured in thousand dollars).\nThe goal is to determine what prices and demand maximizes the total revenue."
  },
  {
    "objectID": "drone_network/drone_network.html",
    "href": "drone_network/drone_network.html",
    "title": "Drone-Network Design Queueing Model",
    "section": "",
    "text": "This notebook uses the model and data from the following studies:\n\nLejeune M.A., Margot F. 2022. Drone-Network Design for Out-of-Hospital Cardiac Arrests. Working Paper, submitted.\nCustodio.J., Lejeune M.A. 2022. Spatiotemporal Data Set of Out-of-Hospital Cardiac Arrests. INFORMS Journal on Computing 34 (1), 4-10.\n\nThe data and its full description can be found here: https://github.com/INFORMSJoC/2020.1022\nThe example reads from the VBOHCAR Excel file that contains data for: - out-of-hospital cardiac arrest (OHCA) incidents - potential base stations for drones - pairwise incident/base station (Harversine) distances\nThe MILP reformulation is modeled in gurobipy and solved using the Gurobi Optimizer.\nTo begin, we import the necessary packages for data intake, modeling, and visualization.\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import collections as mc\nimport numpy as np\nimport gurobipy as gp\nfrom gurobipy import GRB\nfrom datetime import datetime\nfrom sklearn.mixture import GaussianMixture\nfrom sklearn.cluster import KMeans\n\n\nInput Data Processing and Visualization\nWe use pandas to quickly read in the required sheets from Excel. There is a small amount of data prep needed, where some duplicate events need to be removed and text should be cleaned. For reference, an incident location encompasses a street block.\n\n# read incident and base station data\nohca_read = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/drone_network_1_2/OHCAs.csv', index_col=0)\nstations_read = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/drone_network_1_2/BaseStations.csv', index_col=0)\n\n# read data on indicent-base distance\ndist_read = pd.read_csv('https://raw.githubusercontent.com/Gurobi/modeling-examples/master/drone_network_1_2/Base_to_OHCA_distance.csv', index_col=[0,1])\n\nThe above reads the complete data set, including all OHCAs, base stations, and respective distances. We will subset indicent data to the last month and select seven stations to get an instance that will solve in the notebook.\n\n# select a subset of OHCAs so the model can be solved in this notebook (if you have a full license then you can use all incidents)\nstart_date = '2019-05-31' \nend_date = '2019-06-30'\nn_days =  (datetime.strptime(end_date, \"%Y-%m-%d\") - datetime.strptime(start_date, \"%Y-%m-%d\")).days\nohca_df = ohca_read[(ohca_read.ReceivedTime &gt;= start_date) & (ohca_read.ReceivedTime &lt;= end_date)]\n\n# select a subset of base stations so the model can be solved in this notebook (if you have a full license then you can use all stations)\nstations_df = stations_read.loc[[2,3,5,14,25,31,35]]\n# some bases are different types (e.g. fire and police), add the type to create a different base name\nstations_df['Base'] = stations_df.Street + ' ' + stations_df.Type\n\ndist = dist_read.loc[dist_read.index.get_level_values(1).isin(ohca_df.index)]\ndist = dist.loc[dist.index.get_level_values(0).isin(stations_df.index)]\nprint(f\"Number of days: {n_days} \\nNumber of OHCAs: {ohca_df.shape[0]}\")\n\nNumber of days: 30 \nNumber of OHCAs: 69\n\n\nNext, we create scatterplots to visualize the OHCA locations and stations.\n\nplt.scatter(data = ohca_df, x = 'Longitude', y = 'Latitude', alpha = .3)\nplt.scatter(data = stations_df, x = 'Longitude', y = 'Latitude', alpha = 0.5, c = 'orange')\n\n&lt;matplotlib.collections.PathCollection at 0x26103255190&gt;\n\n\n\n\n\n\n# create a base / OHCA data frame using the location names\ndf = dist.join(ohca_df[['Incident_Location']])\ndf = df.join(stations_df['Base'])\ndf = df.drop_duplicates()\ndf = df.set_index(['Incident_Location','Base'])\n\n\n\nMILP Model\n\nParameter Calculation\nWe assume that drones at each station will have the same speed and mainenace times. The total time it takes a drone to service an OHCA is travel time (to and back from the OHCA location) plus maintenance time.\n\n# limit number of drones\nn_drones = 4\n# assume a 100 km/hr drone speed (about 38 mph) for each drone\nspeed = 100\n# average time to prep, dispatch, clean, perform maintenance etc. a drone is 25 min, converted to hours\nmaintenance = 25/60\n# calculate average service time from i to j (converting to meters to kilometers)\ndistance = df['Harversine Distance (meters)']\nservice_time = maintenance + 2*0.001*distance/speed\nservice_time = service_time.rename('service_time')\n\nNext, we use the MLE for the arrival rate of an OHCA to each location \\(i\\) as \\(\\lambda_{i} = N_i/t\\), where \\(N_i\\) is the number of incidents over time \\(t\\).\n\nincident_count = ohca_df.Incident_Location.value_counts()\n# arrival rate is in hours to match drone speed units\narrival_rate = round(incident_count/(24*n_days),6) \n\nI = df.index.get_level_values(0).unique()\nJ = df.index.get_level_values(1).unique()\n\n# make list of each OHCA / base pair\nbase_to_ohca = df.index.tolist()\n\n# print DAILY arrival rates for each location \n24*arrival_rate.sort_values(ascending = False)\n\n1700 PLEASURE HOUSE RD    0.066672\n1800 DOLINA DR            0.033336\n3600 BONNEY RD            0.033336\n3400 CHAMPLAIN LA         0.033336\n2400 LAUREL COVE DR       0.033336\n                            ...   \n4400 SANIBEL CI           0.033336\n1600 OLD DONATION PKWY    0.033336\n600 FLEET DR              0.033336\n200 ARAGONA BL            0.033336\n1200 GENERAL ST           0.033336\nName: Incident_Location, Length: 68, dtype: float64\n\n\n\n\nBase Formualtion (BF) Variables and Constraints\nWe start to build the MILP model by introducing binary variables \\(x_{j}\\) and \\(y_{i,j}\\) which will be 1 if location \\(j\\) is chosen and services OHCA \\(i\\). We start with constraints typical to facility location problem. \\[\\begin{align}\n&y_{i,j} \\le x_j \\\\\n&\\sum_{j \\in J} x_j \\le p \\\\\n&\\sum_{i \\in I_{j}} y_{i,j} = 1 \\\\\n\\end{align}\\]\nNext, we require each queue meet stability requirements: \\[\\begin{align}\n\\sum_{i \\in I_{j}}\\lambda_{i}s_{i,j}y_{i,j} \\le 1\n\\end{align}\\]\nBelow are these constaints written in gurobipy.\n\nm = gp.Model('drone_network')\n\nx = m.addVars(J, vtype=GRB.BINARY, name='x')            #selection\ny = m.addVars(base_to_ohca, vtype=GRB.BINARY, name='y') #assignment\n\nm.addConstrs((y[(i,j)] &lt;= x[j] for i,j in base_to_ohca), name='select')\nm.addConstr(x.sum() &lt;= n_drones, name = 'drone_limit')\nm.addConstrs((y.sum(i,'*') == 1 for i in I), name = 'ohca');\nm.addConstrs(((gp.quicksum(arrival_rate[i]*service_time[i,j]*y[(i,j)] for i in I) &lt;= 1) for j in J), name='stability');\n\n\n\nReformulated MILP: Auxilary Variables, Constraints, and Objective Function\nThe objective for the original formulation is to minimize the average expected response time of the drone network. \\[\\begin{align}\n\\text{min}\\space \\frac{1}{\\sum_{k \\in I}\\lambda_k} \\sum_{i \\in I} \\sum_{j \\in J_{i}} \\left(\\frac{\\lambda_iy_{i,j} \\sum_{k \\in I}\\lambda_ky_{k,j}s^{2}_{k,j} }{2[1-\\sum_{k \\in I}\\lambda_ky_{k,j}s_{k,j}]} + \\frac{d_{i,j}\\lambda_iy_{i,j}}{v_j}\\right)\n\\end{align}\\]\nThe objective function contains factional and bilinear terms but can be reformualted in such a way that these terms are removed and linearized, creating a MILP. To do this, Linking variables need to be introduced to create the reformulation.\n\\[\\begin{align}\n&V_j = \\sum_{i \\in I_{j}} \\lambda_is^{2}_{i,j}y_{i,j} + \\sum_{i \\in I_{j}} \\lambda_is_{i,j}y_{i,j} \\\\\n&\\nu_{i,j} \\ge 0 \\\\\n&\\nu_{i,j} \\ge \\overline{V}(y_{i,j}-1) + V_j \\\\\n&\\nu_{i,j} \\le \\overline{V}y_{i,j} \\\\\n&\\nu_{i,j} \\le V_j \\\\\n\\end{align}\\]\nThe objective function now is: \\[\\begin{align}\n\\text{min}\\space \\sum_{i \\in I} \\sum_{j \\in J_{i}} \\left(\\frac{\\nu_{i,j}}{2} + \\frac{d_{i,j}y_{i,j}}{v_j}\\right)\\frac{\\lambda_i}{\\sum_{k \\in I}\\lambda_k}\n\\end{align}\\]\n\n# Auxilary variables and constraints for R-MILP\nVbar = 2*service_time.sum()\nV = m.addVars(J, ub = Vbar, name = 'V')\nnu = m.addVars(base_to_ohca, name='nu')\n\nm.addConstrs((V[j] == gp.quicksum(arrival_rate[i]*service_time[i,j]**2*y[i,j] for i in I) + gp.quicksum(arrival_rate[i]*service_time[i,j]*nu[i,j] for i in I) for j in J), name = 'aux0')\nm.addConstrs((nu[i,j] &lt;= V[j] for i, j in base_to_ohca), name = 'aux1')\nm.addConstrs((nu[i,j] &lt;= Vbar*y[i,j] for i, j in base_to_ohca), name = 'aux2')\nm.addConstrs((nu[i,j] &gt;= Vbar*(y[i,j]-1) + V[j] for i, j in base_to_ohca), name = 'aux3')\n\n# for ease in setting the objective there is a bit a simplification\nL = arrival_rate.sum()\nm.setObjective((1/L)*(gp.quicksum(0.5*arrival_rate[i]*nu[(i,j)] + (arrival_rate[i]*distance[i,j]/speed)*y[(i,j)] for i, j in base_to_ohca)));\n\nRun the optimization:\n\nm.optimize()\n\nGurobi Optimizer version 10.0.2 build v10.0.2rc0 (win64)\n\nCPU model: 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz, instruction set [SSE2|AVX|AVX2|AVX512]\nThread count: 4 physical cores, 8 logical processors, using up to 8 threads\n\nOptimize a model with 1987 rows, 966 columns and 6202 nonzeros\nModel fingerprint: 0xdb44b4e9\nVariable types: 483 continuous, 483 integer (483 binary)\nCoefficient statistics:\n  Matrix range     [2e-04, 6e+02]\n  Objective range  [7e-03, 5e+00]\n  Bounds range     [1e+00, 6e+02]\n  RHS range        [1e+00, 6e+02]\nPresolve removed 7 rows and 0 columns\nPresolve time: 0.06s\nPresolved: 1980 rows, 966 columns, 6202 nonzeros\nVariable types: 483 continuous, 483 integer (483 binary)\n\nRoot relaxation: objective 3.732321e+01, 202 iterations, 0.01 seconds (0.01 work units)\n\n    Nodes    |    Current Node    |     Objective Bounds      |     Work\n Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time\n\n*    0     0               0      37.3232102   37.32321  0.00%     -    0s\n\nExplored 1 nodes (202 simplex iterations) in 0.10 seconds (0.09 work units)\nThread count was 8 (of 8 available processors)\n\nSolution count 1: 37.3232 \n\nOptimal solution found (tolerance 1.00e-04)\nBest objective 3.732321020846e+01, best bound 3.732321020846e+01, gap 0.0000%\n\n\n\n\nVisualize the Solution Network\nUse getAttr in gurobipy to quickly get the \\(x\\) and \\(y\\) decision variable values.\n\n# recover the bases used in the optimal solution\nsol_x = pd.Series(m.getAttr('X',x))\nbases_selected = sol_x[sol_x &gt; 0.5]\nbases_selected\n\n21 MUNICIPAL CTR Fire Station           1.0\n800 VIRGINIA BEACH BLVD Fire Station    1.0\n3769 E. STRATFORD ROAD Rescue Squad     1.0\n5145 RURITAN COURT Rescue Squad         1.0\ndtype: float64\n\n\nNow export the assignment variables and create a dataframe with the coordinates for each final indicent/base pair\n\n# recover the assignment variable\nsol_y = pd.Series(m.getAttr('X',y))\nsol_y.name = 'Assignments'\nsol_y.index.names = ['Incident_Location','Base']\nassignment = sol_y[sol_y &gt; 0.5].to_frame()\nassignment = pd.merge(assignment.reset_index()[['Incident_Location','Base']], ohca_df[['Incident_Location','Latitude','Longitude']])\nassignment.rename(columns = {'Latitude':'Inc_Latitude', 'Longitude': 'Inc_Longitude'}, inplace = True)\nassignment = pd.merge(assignment, stations_df[['Base','Latitude','Longitude']])\nassignment.rename(columns = {'Latitude':'Base_Latitude', 'Longitude': 'Base_Longitude'}, inplace = True)\n\nWe can now visualize the solution by finding the coordinates for each assignment pair and creating a plot with the incidents and stations to visualize the final network. The light orange points are stations that were not selected.\n\ncoords = []\nfor r in range(assignment.shape[0]):\n    coords.append([(assignment.Base_Longitude[r],assignment.Base_Latitude[r]),(assignment.Inc_Longitude[r],assignment.Inc_Latitude[r])])\n# plot the line segments, indicent points, and base station points of the final network\nfig, ax = plt.subplots()\nax.set_xlim(-76.23, -75.93)\nax.set_ylim(36.72, 36.93)\nlc = mc.LineCollection(coords, alpha = .2)\nax.add_collection(lc)\nplt.scatter(data = ohca_df, x = 'Longitude', y = 'Latitude', alpha = .3)\nplt.scatter(data = stations_df[stations_df['Base'].isin(bases_selected.index.tolist())], x = 'Longitude', y = 'Latitude', alpha = 1, c = 'orange') \nplt.scatter(data = stations_df[~stations_df['Base'].isin(bases_selected.index.tolist())], x = 'Longitude', y = 'Latitude', alpha = 0.2, c = 'orange') \nplt.show()\n\n\n\n\n\nm.dispose()\ngp.disposeDefaultEnv()\n\nFreeing default Gurobi environment"
  },
  {
    "objectID": "efficiency_analysis/efficiency_analysis.html",
    "href": "efficiency_analysis/efficiency_analysis.html",
    "title": "Efficiency Analysis",
    "section": "",
    "text": "The Data Envelopment Analysis (DEA) is a nonparametric problem in operations research and economics whose solution is an estimation of production frontiers. It is used to empirically measure the productive efficiency of decision making units (DMUs). There are a number of linear programming formulations of the DEA problem. Fuller coverage of the subject can be found in Farrell (1957), Charnes et al. (1978) and Thanassoulis et al. (1987). The formulation given by H.P. Williams is described in Land (1991). This formulation is the dual model of a model commonly used that relies on finding weighted ratios of outputs to inputs. We will use the formulation that is commonly used and can be found in Cooper et al. (2007).\nThe Data Envelopment Analysis has been used to evaluate the performance of many different kinds of entities engaged in many different activities, and in many different contexts in many different countries. Examples include the maintenance activities of U.S. Air Force bases in different geographic locations, or police forces in England and Wales as well as the performance of branch banks in Cyprus and Canada and the efficiency of universities in performing their education and research functions in the U.S., England and France.\nThe DEA approach is concerned with evaluations of efficiency. The most common measure of efficiency takes the form of a ratio like the following one:\n\\[\n\\text{efficiency} = \\frac{\\text{output}}{\\text{input}}\n\\]"
  },
  {
    "objectID": "efficiency_analysis/efficiency_analysis.html#background",
    "href": "efficiency_analysis/efficiency_analysis.html#background",
    "title": "Efficiency Analysis",
    "section": "",
    "text": "The Data Envelopment Analysis (DEA) is a nonparametric problem in operations research and economics whose solution is an estimation of production frontiers. It is used to empirically measure the productive efficiency of decision making units (DMUs). There are a number of linear programming formulations of the DEA problem. Fuller coverage of the subject can be found in Farrell (1957), Charnes et al. (1978) and Thanassoulis et al. (1987). The formulation given by H.P. Williams is described in Land (1991). This formulation is the dual model of a model commonly used that relies on finding weighted ratios of outputs to inputs. We will use the formulation that is commonly used and can be found in Cooper et al. (2007).\nThe Data Envelopment Analysis has been used to evaluate the performance of many different kinds of entities engaged in many different activities, and in many different contexts in many different countries. Examples include the maintenance activities of U.S. Air Force bases in different geographic locations, or police forces in England and Wales as well as the performance of branch banks in Cyprus and Canada and the efficiency of universities in performing their education and research functions in the U.S., England and France.\nThe DEA approach is concerned with evaluations of efficiency. The most common measure of efficiency takes the form of a ratio like the following one:\n\\[\n\\text{efficiency} = \\frac{\\text{output}}{\\text{input}}\n\\]"
  },
  {
    "objectID": "efficiency_analysis/efficiency_analysis.html#model-formulation",
    "href": "efficiency_analysis/efficiency_analysis.html#model-formulation",
    "title": "Efficiency Analysis",
    "section": "Model Formulation",
    "text": "Model Formulation\nAssume there is a set of DMUs. Some common input and output items for each of these DMUs are selected as follows: 1. Numerical data are available for each input and output, with the data assumed to be positive, for all DMUs. 2. The items (inputs, outputs and choice of DMUs) should reflect an analyst’s or a manager’s interest in the components that will enter into the relative efficiency evaluations of the DMUs. 3. In principle, smaller input amounts are preferable and larger output amounts are preferable so the efficiency scores should reflect these principles. 4. The measurement units of the different inputs and outputs do not need to be congruent. Some may involve a number of persons, or areas of floor space, money expended, etc.\n\nFractional problem formulation\nThe proposed measure of the efficiency of a target DMU \\(k\\) is obtained as the maximum of a ratio of weighted outputs to weighted inputs subject to the condition that the similar ratios for every DMU be less than or equal to one.\n\n\nSets and indices\n\\(j,k \\in \\text{DMUS}\\): Indices and set of DMUs, where \\(k\\) represents the target DMU.\n\\(i \\in \\text{Inputs}\\): Index and set of inputs.\n\\(r \\in \\text{Outputs}\\): Index and set of outputs.\n\n\nParameters\n\\(\\text{invalue}_{i,j} &gt; 0\\): Value of input \\(i\\) for DMU \\(j\\).\n\\(\\text{outvalue}_{r,j} &gt; 0\\): Value of output \\(r\\) for DMU \\(j\\).\n\n\nDecision Variables\n\\(u_{r} \\geq 0\\): Weight of output \\(r\\).\n\\(v_{i} \\geq 0\\): Weight of input \\(i\\).\n\n\nObjective function\nTarget DMU Efficiency: Maximize efficiency at the target DMU \\(k\\).\n\\[\n\\text{Maximize} \\quad E_k =\n\\frac{\\sum_{r \\in \\text{Outputs}} \\text{outvalue}_{r,k}*u_{r}}{\\sum_{i \\in \\text{Inputs}} \\text{invalue}_{i,k}*v_{i}}\n\\tag{FP0}\n\\]\n\n\nConstraints\nEfficiency ratios: The efficiency of a DMU is a number between \\([0,1]\\).\n\\[\\begin{equation}\n\\frac{\\sum_{r \\in \\text{Outputs}} \\text{outvalue}_{r,j}*u_{r}}{\\sum_{i \\in \\text{Inputs}} \\text{invalue}_{i,j}*v_{i}}\n\\leq 1 \\quad \\forall j \\in \\text{DMUS}\n\\tag{FP1}\n\\end{equation}\\]"
  },
  {
    "objectID": "economic_planning/economic_planning.html",
    "href": "economic_planning/economic_planning.html",
    "title": "Economic Planning",
    "section": "",
    "text": "In this problem, we assume that we have an economy with three types of industries:\n\nCoal\nSteel\nTransport\n\nPart of the outputs from these industries are needed as inputs to others. For example, coal is needed to fire the blast furnaces that produce steel, steel is needed in the machinery for extracting coal, etc. We measure all units of production in monetary terms. That is, each dollar of production by one of the industries requires inputs (in dollars) from possibly its own industry as well as other industries. The required inputs as well as the labor requirements (also measured in dollars) are shown in the following table.\n\n\n\ninput (t) /  output (t+1)\nCoal\nSteel\nTransport\n\n\n\n\nCoal\n0.1\n0.5\n0.4\n\n\nSteel\n0.1\n0.1\n0.2\n\n\nTransport\n0.2\n0.1\n0.2\n\n\nLabor\n0.6\n0.3\n0.2\n\n\nTotal\n1\n1\n1\n\n\n\nThere is a time lag in the economy so that the output in year t +1 requires an input in year t. For example, to produce one-dollar worth of coal requires 0.1 dollars of coal (to provide the necessary power), 0.1 dollars of steel (the steel ‘used up’ in the ‘wear and tear’ on the machinery) and 0.2 dollars of transport (for moving the coal from the mine). In addition, 0.6 dollars of manpower is required. Similarly, the other columns of the table give the inputs required (in dollars) for each dollar of steel and each dollar of transport (trucks, cars, trains, etc.). Notice that the value of each unit of output is exactly matched by the sum of the values of its inputs.\nOutput from an industry may also be used to build productive capacity for itself or other industries in future years. The inputs required to give unit increases (capacity in dollars’ worth of extra production) in productive capacity are given in the following table. Input from an industry in year t results in a (permanent) increase in productive capacity in year t +2.\n\n\n\ninput (t) /  output (t+2)\nCoal\nSteel\nTransport\n\n\n\n\nCoal\n0.1\n0.7\n0.9\n\n\nSteel\n0.1\n0.1\n0.2\n\n\nTransport\n0.2\n0.1\n0.2\n\n\nLabor\n0.4\n0.2\n0.1\n\n\n\nStocks of goods may be held from year to year. At present (the beginning of year 1), the stocks and productive capacities (per year) are given in the following table (in millions of dollars).\n\n\n\nPresent\nStocks\nProductive Capacity\n\n\n\n\nCoal\n150\n300\n\n\nSteel\n80\n350\n\n\nTransport\n100\n280\n\n\n\nWe want to maximize the total manpower utilization i.e. employment, over the planning horizon while meeting an exogenous consumption requirement in every year:\n\n60 million dollars of coal.\n60 million dollars of steel.\n30 million dollars of transport."
  },
  {
    "objectID": "economic_planning/economic_planning.html#problem-description",
    "href": "economic_planning/economic_planning.html#problem-description",
    "title": "Economic Planning",
    "section": "",
    "text": "In this problem, we assume that we have an economy with three types of industries:\n\nCoal\nSteel\nTransport\n\nPart of the outputs from these industries are needed as inputs to others. For example, coal is needed to fire the blast furnaces that produce steel, steel is needed in the machinery for extracting coal, etc. We measure all units of production in monetary terms. That is, each dollar of production by one of the industries requires inputs (in dollars) from possibly its own industry as well as other industries. The required inputs as well as the labor requirements (also measured in dollars) are shown in the following table.\n\n\n\ninput (t) /  output (t+1)\nCoal\nSteel\nTransport\n\n\n\n\nCoal\n0.1\n0.5\n0.4\n\n\nSteel\n0.1\n0.1\n0.2\n\n\nTransport\n0.2\n0.1\n0.2\n\n\nLabor\n0.6\n0.3\n0.2\n\n\nTotal\n1\n1\n1\n\n\n\nThere is a time lag in the economy so that the output in year t +1 requires an input in year t. For example, to produce one-dollar worth of coal requires 0.1 dollars of coal (to provide the necessary power), 0.1 dollars of steel (the steel ‘used up’ in the ‘wear and tear’ on the machinery) and 0.2 dollars of transport (for moving the coal from the mine). In addition, 0.6 dollars of manpower is required. Similarly, the other columns of the table give the inputs required (in dollars) for each dollar of steel and each dollar of transport (trucks, cars, trains, etc.). Notice that the value of each unit of output is exactly matched by the sum of the values of its inputs.\nOutput from an industry may also be used to build productive capacity for itself or other industries in future years. The inputs required to give unit increases (capacity in dollars’ worth of extra production) in productive capacity are given in the following table. Input from an industry in year t results in a (permanent) increase in productive capacity in year t +2.\n\n\n\ninput (t) /  output (t+2)\nCoal\nSteel\nTransport\n\n\n\n\nCoal\n0.1\n0.7\n0.9\n\n\nSteel\n0.1\n0.1\n0.2\n\n\nTransport\n0.2\n0.1\n0.2\n\n\nLabor\n0.4\n0.2\n0.1\n\n\n\nStocks of goods may be held from year to year. At present (the beginning of year 1), the stocks and productive capacities (per year) are given in the following table (in millions of dollars).\n\n\n\nPresent\nStocks\nProductive Capacity\n\n\n\n\nCoal\n150\n300\n\n\nSteel\n80\n350\n\n\nTransport\n100\n280\n\n\n\nWe want to maximize the total manpower utilization i.e. employment, over the planning horizon while meeting an exogenous consumption requirement in every year:\n\n60 million dollars of coal.\n60 million dollars of steel.\n30 million dollars of transport."
  },
  {
    "objectID": "economic_planning/economic_planning.html#model-formulation",
    "href": "economic_planning/economic_planning.html#model-formulation",
    "title": "Economic Planning",
    "section": "Model Formulation",
    "text": "Model Formulation\nA widely used type of national economic model is the input–output model representing the interrelationships between the different sectors of a country’s economy. Such models are often referred to as dynamic Leontief models after their originator, who built such a model of the American economy. A similar model has been considered by Wagner (1957).\n\nSets and indices\n\\(i,j \\in \\text{Industries}=\\{\\text{coal}, \\text{steel}, \\text{transport}\\}\\)\n$ t = {, , , , , }$\n$ t = {, , , , }$\n$t H_{2,4} = {year2, year3, year4 } $\n\n\nParameters\n\\(\\text{demand}_{j} \\in \\mathbb{R}^+\\): Exogenous demand of goods in industry \\(j\\).\n\\(\\text{initial_stock}_{j} \\in \\mathbb{R}^+\\): Stocks of goods in industry \\(j\\) available at the beginning of year 1.\n\\(\\text{in_out_prod}_{i,j} \\in \\mathbb{R}^+\\): Input of good \\(i\\) required to produce one unit of good \\(j\\) in the following year.\n\\(\\text{in_out_cap}_{i,j} \\in \\mathbb{R}^+\\): Input of good \\(i\\) in current year results in a permanent increase in productive capacity of good \\(j\\) two years later.\n\\(\\text{industry_cap}_{j} \\in \\mathbb{R}^+\\): Industry \\(j\\) productive capacity at the beginning of year 1.\n\\(\\text{labor_prod}_{j} \\in \\mathbb{R}^+\\): Labor requirements for the production of goods in industry \\(j\\).\n\\(\\text{labor_extra_cap}_{j} \\in \\mathbb{R}^+\\): Labor requirements to permanently increase capacity for goods in industry \\(j\\).\n\n\nDecision Variables\n\\(\\text{production}_{j,t} \\in \\mathbb{R}^+\\): Production of goods in industry \\(j\\) available at year \\(t\\), in millions of dollars. Note: goods of industry j, in millions of dollars, available in year t but produced in previous year.\n\\(\\text{stock}_{j,t} \\in \\mathbb{R}^+\\): Stock level of industry \\(j\\) at the end of year \\(t\\), in millions of dollars.\n\\(\\text{extra_cap}_{j,t} \\in \\mathbb{R}^+\\): Extra capacity for industry \\(j\\) becoming effective at the beginning of year \\(t\\), in millions of dollars.\nIn order to build a realistic model, we need to think beyond year 5. Therefore, we make the following assumptions:\n\nExternal demand is constant up to year 5 and beyond.\nStock level remains constant at year 5 and beyond.\nCapacity cannot be increased after year 5.\n\nConsequently, for year 6 and beyond, we can assume a static model of the economy. For this static model, the production of goods in each industry \\(i \\in \\text{Industries}\\) can be computed as follows.\n\\[\\begin{equation}\nx_{i} = \\text{demand}_{i} + \\sum_{j \\in \\text{Industries} } \\text{in_out_prod}_{i,j} * x_{j}\n\\end{equation}\\]\nWhere \\(x_{i}\\) is the production of goods in industry \\(i\\).\nSolving this system of equations gives lower bounds for the production of goods in years beyond year 5. Then, the production of goods of industry \\(j \\in \\text{Industries}\\) in year 6 and beyond can be defined by the following constraints.\n\\[\n\\text{production}_{j,t} \\geq x_{j} \\quad \\forall j \\in \\text{Industries}, \\; t=6.\n\\]\n\\[\n\\text{extra_cap}_{j,t} = 0 \\quad \\forall j \\in \\text{Industries}, \\; t=6.\n\\]\n\n\nConstraints\nBalance equation year 1: The initial stocks in industry \\(i\\) should be equal to the total demand (internal and external), plus the extra capacity to build, plus the stock level at the end of year 1 of the goods in that industry.\n\\[\\begin{equation}\n\\text{initial_stock}_{i} = \\sum_{j \\in \\text{Industries} } \\text{in_out_prod}_{i,j}*\\text{production}_{j,2}\n+ \\text{demand}_{i} + \\sum_{j \\in \\text{Industries} } \\text{in_out_cap}_{i,j}*\\text{extra_cap}_{j,3} +\n\\text{stock}_{i,1}\n\\end{equation}\\]\nBalance equation for year 2, year 3, year 4: The production of goods in industry \\(i\\) at year t plus the stocks at the end of year t-1 should be equal to the total demand (internal and external), plus the extra capacity to build, plus the stock level at the end of year t of the goods in that industry.\n\\[\\begin{equation}\n\\text{production}_{j,t} + \\text{stock}_{i,t-1} =\n\\sum_{j \\in \\text{Industries} } \\text{in_out_prod}_{i,j}*\\text{production}_{j,t+1} + \\text{demand}_{i} +\n\\sum_{j \\in \\text{Industries} } \\text{in_out_cap}_{i,j}*\\text{extra_cap}_{j,t+2}\n+ \\text{stock}_{i,t} \\quad \\forall t \\in H_{2,4}\n\\end{equation}\\]\nBalance equation year 5: The production of goods in industry \\(i\\) plus the stocks at the end of year 4 should be equal to the total demand (internal and external), plus the stock level at the end of year 5 of the goods in that industry.\n\\[\\begin{equation}\n\\text{production}_{j,5} + \\text{stock}_{i,4} =\n\\sum_{j \\in \\text{Industries} } \\text{in_out_prod}_{i,j}*\\text{production}_{j,6}  +\n\\text{demand}_{i} + \\text{stock}_{i,5}\n\\end{equation}\\]\nEnd of horizon constraints:\n\\[\n\\text{production}_{j,t} \\geq x_{j} \\quad \\forall j \\in \\text{Industries}, \\; t=6\n\\]\n\\[\n\\text{extra_cap}_{j,t} = 0 \\quad \\forall j \\in \\text{Industries}, \\; t=6\n\\]\nWhere \\(x_{j}\\) is the solution of the static model.\nProductive capacity constraints: These constraints ensure that the production of goods for each industry \\(j\\) during the planning horizon do not exceed the total production capacity at that year.\n\\[\\begin{equation}\n\\text{production}_{j,t} \\leq \\text{base_cap}_{j} + \\sum_{\\tau \\leq t} \\text{extra_cap}_{j,\\tau} \\quad \\forall t \\in \\text{Horizon}\n\\end{equation}\\]\n\n\nObjective Function\nLabor utilization: Maximize labor employment.\n\\[\\begin{equation}\n\\text{Maximize} \\quad Z =\n\\sum_{t \\in \\text{fiveYears} } \\sum_{j \\in \\text{Industries} } \\text{labor_prod}_{j}*\\text{production}_{j,t} +\n\\sum_{t \\in \\text{fiveYears} } \\sum_{j \\in \\text{Industries} } \\text{labor_extra_cap}_{j}*\\text{extra_cap}_{j,t}\n\\end{equation}\\]"
  },
  {
    "objectID": "economic_planning/economic_planning.html#python-implementation",
    "href": "economic_planning/economic_planning.html#python-implementation",
    "title": "Economic Planning",
    "section": "Python Implementation",
    "text": "Python Implementation\nWe import the Gurobi Python Module and other Python libraries."
  }
]